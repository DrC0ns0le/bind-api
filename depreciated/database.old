package main

import (
	"database/sql"
	"fmt"
	"log"
	"os"

	_ "github.com/lib/pq"
)

type DB struct {
	db *sql.DB
}

func NewDB(dataSourceName string) (*DB, error) {
	db, err := sql.Open("postgres", dataSourceName)
	if err != nil {
		return nil, err
	}
	return &DB{db: db}, nil
}

func (db *DB) Close() error {
	return db.db.Close()
}

func (db *DB) GetZones() ([]Zone, error) {
	rows, err := db.db.Query("SELECT id, uuid, name FROM zones")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var zones []Zone
	for rows.Next() {
		var zone Zone
		err := rows.Scan(&zone.ID, &zone.UUID, &zone.Name)
		if err != nil {
			return nil, err
		}

		zone.Records, err = db.GetRecordsForZone(zone.UUID)
		if err != nil {
			return nil, err
		}

		zones = append(zones, zone)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return zones, nil
}

func (db *DB) GetRecordsForZone(zoneUUID string) ([]DNSRecord, error) {
	rows, err := db.db.Query("SELECT id, uuid, type, host, content, ttl, last_modified, zone_uuid FROM dns_records WHERE zone_uuid = $1", zoneUUID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var records []DNSRecord
	for rows.Next() {
		var record DNSRecord
		err := rows.Scan(&record.ID, &record.UUID, &record.Type, &record.Host, &record.Content, &record.TTL, &record.LastModified, &record.ZoneUUID)
		if err != nil {
			return nil, err
		}
		records = append(records, record)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return records, nil
}

// Define other methods for CRUD operations if needed...

func init() {
	db, err := NewDB("postgresql://postgres:jack2001@10.2.1.2/dbname?sslmode=disable")
	if err != nil {
		log.Fatal(err)
		os.Exit(2)
	}
	defer db.Close()

	zones, err := db.GetZones()
	if err != nil {
		log.Fatal(err)
	}

	for _, zone := range zones {
		fmt.Printf("Zone: %s\n", zone.Name)
		for _, record := range zone.Records {
			fmt.Printf("  Record: %s %s %s\n", record.Type, record.Host, record.Content)
		}
	}
}
